#!/usr/bin/python3
import glob
import sys
import json
import textwrap
from Bibliography import Bibliography
from FriendlyArgumentParser import FriendlyArgumentParser
from LintChecks import known_lint_checks
from HTMLComplaintRenderer import HTMLComplaintRenderer
from Citations import Citations
from OptionSet import OptionSet
from BibUtils import BibUtils

known_lint_check_names = sorted(known_lint_checks.keys())

def print_check_descriptions(f):
	print(file = f)
	print("detailed list of checks:", file = f)
	check_classes = [ cls for cls in known_lint_checks.values() ]
	check_classes.sort(key = lambda cls: cls.name)
	for check_cls in check_classes:
		print(" - %s" % (check_cls.name), file = f)
		description = textwrap.dedent(check_cls.description).strip()
		for paragraph in description.split("\n"):
			if paragraph != "":
				for line in textwrap.wrap(paragraph, initial_indent = "      ", subsequent_indent = "      "):
					print(line, file = f)
				print(file = f)

oset = OptionSet(known_lint_check_names, default_str = "ALL:-check-local-copies:-check-similar-titles")
parser = FriendlyArgumentParser()
parser.set_additional_help_callback(print_check_descriptions)
parser.add_argument("-c", "--check", metavar = "checkstr", type = str, default = oset.default_str, help = "Checks to perform. Defaults to %(default)s. Recognized checks are " + (", ".join(known_lint_check_names)) + ". Special values are ALL or DEFAULT. A valid lint check string is separated by colons and every item is prefixed with + or -. The plus character can be omitted, the string is case-insensitive. One example would be '+foo-check:+bar-check' to only check 'foo' and 'bar'. Another one would be 'DEFAULT:-dumb-check' to check the ones enabled by default but disable 'dumb'. ")
parser.add_argument("-i", "--ignore-suppressions", action = "store_true", help = "Do not honor suppressions and always emit warnings.")
parser.add_argument("-f", "--format", choices = [ "short", "long", "json", "html", "quickfix" ], default = "short", help = "Display the lint messages in the specified format. Choices are %(choices)s, default is %(default)s.")
parser.add_argument("-o", "--output", metavar = "path", default = "-", help = "Specifies where to output the specific data to. Can be stdout by specifying '-'. Defaults to %(default)s.")
parser.add_argument("-l", "--localdir", metavar = "path", default = "bibliography/", help = "Points to the directory where the local bibliography is expected. Defaults to %(default)s.")
parser.add_argument("-a", "--action", choices = [ "lint", "authorscan", "prettyprint" ], default = "lint", help = "Specifies the action that should be done with the given files. Can be one of %(choices)s, default is %(default)s. 'lint' does a regular lint scan, 'authorscan' outputs a JSON file of all authors and 'prettyprint' emits the scanned bibliography in a pretty-printed version.")
parser.add_argument("-t", "--tex", metavar = "texfile", type = str, action = "append", default = [ ], help = "Also parses a number of TeX files to be able to identify citations which are unused. Supports globbing in order to select multiple files.")
parser.add_argument("-v", "--verbose", action = "store_true", help = "Be more verbose when checking")
parser.add_argument("bibfiles", metavar = "bibfile", type = str, nargs = "+", help = "Bibliography files which should be checked")
args = parser.parse_args(sys.argv[1:])

apply_check_names = oset.parse(args.check)
apply_checks = [ known_lint_checks[name] for name in apply_check_names ]
apply_checks.sort(key = lambda chk: chk.name)

bibliography = Bibliography(args.bibfiles)
if args.verbose:
	print("Parsed %d bibliography entries." % (len(bibliography)))

citations = None
for texfile_glob in args.tex:
	citations = Citations()
	for filename in glob.glob(texfile_glob):
		citations.read_from_file(filename)
	if args.verbose:
		print("Parsed %d citations from TeX." % (len(citations)))

if args.output == "-":
	outfile = sys.stdout
else:
	outfile = open(args.output, "w")

with outfile:
	if args.action == "lint":
		complaints = [ ]
		for check_class in apply_checks:
			if args.verbose:
				print("Now checking %s" % (check_class.name))

			checker = check_class(args, bibliography, citations)
			if check_class.linttype == "per_entry":
				for entry in bibliography:
					if entry.suppressed(check_class.name) and (not args.ignore_suppressions):
						# Suppress this entry
						continue

					for complaint in checker.check_entry(entry):
						complaints.append(complaint)
			elif check_class.linttype == "once":
				for complaint in checker.check_all():
					complaints.append(complaint)
			else:
				raise Exception("Unknown linttype %s for checker %s" % (check_class.linttype, check_class.name))
		complaints.sort()

		if args.verbose:
			print("%d complaints found." % (len(complaints)))

		if args.format == "short":
			for complaint in complaints:
				complaint.short_dump(file = outfile)
		elif args.format == "long":
			for complaint in complaints:
				complaint.long_dump(file = outfile)
		elif args.format == "json":
			complaint_data = [ complaint.to_dict() for complaint in complaints ]
			print(json.dumps(complaint_data), file = outfile)
		elif args.format == "html":
			renderer = HTMLComplaintRenderer(complaints)
			print(renderer.render(), file = outfile)
		elif args.format == "quickfix":
			for complaint in complaints:
				complaint.print_vim_quickfix(outfile)
		else:
			raise Exception(NotImplemented)
	elif args.action == "authorscan":
		BibUtils(bibliography).author_scan(file = outfile)
	elif args.action == "prettyprint":
		bibliography.pretty_print(file = outfile)
	else:
		raise Exception(NotImplemented)

