#!/usr/bin/python3
import glob
import sys
import json
import textwrap
from Bibliography import Bibliography
from FriendlyArgumentParser import FriendlyArgumentParser
from HTMLComplaintRenderer import HTMLComplaintRenderer
from Citations import Citations
from OptionSet import OptionSet
from BibUtils import BibUtils
from LintDB import LintDB
import BibLintChecks
import TexLintChecks

db = LintDB()
db.scan_module(BibLintChecks)
db.scan_module(TexLintChecks)

oset = OptionSet(db.known_check_names, default_str = "ALL:-check-local-copies:-check-similar-titles")
parser = FriendlyArgumentParser()
parser.set_additional_help_callback(db.print_help)
parser.add_argument("-c", "--check", metavar = "checkstr", type = str, default = oset.default_str, help = "Checks to perform. Defaults to %(default)s. Recognized checks are " + (", ".join(db.known_check_names)) + ". Special values are ALL or DEFAULT. A valid lint check string is separated by colons and every item is prefixed with + or -. The plus character can be omitted, the string is case-insensitive. One example would be '+foo-check:+bar-check' to only check 'foo' and 'bar'. Another one would be 'DEFAULT:-dumb-check' to check the ones enabled by default but disable 'dumb'. ")
parser.add_argument("-i", "--ignore-suppressions", action = "store_true", help = "Do not honor suppressions and always emit warnings.")
parser.add_argument("-f", "--format", choices = [ "short", "long", "json", "html", "quickfix" ], default = "short", help = "Display the lint messages in the specified format. Choices are %(choices)s, default is %(default)s.")
parser.add_argument("-o", "--output", metavar = "path", default = "-", help = "Specifies where to output the specific data to. Can be stdout by specifying '-'. Defaults to %(default)s.")
parser.add_argument("-l", "--localdir", metavar = "path", default = "bibliography/", help = "Points to the directory where the local bibliography is expected. Defaults to %(default)s.")
parser.add_argument("-a", "--action", choices = [ "lint", "authorscan", "prettyprint" ], default = "lint", help = "Specifies the action that should be done with the given files. Can be one of %(choices)s, default is %(default)s. 'lint' does a regular lint scan, 'authorscan' outputs a JSON file of all authors and 'prettyprint' emits the scanned bibliography in a pretty-printed version.")
parser.add_argument("-t", "--tex", metavar = "texfile", type = str, action = "append", default = [ ], help = "Also parses a number of TeX files to be able to identify citations which are unused. Supports globbing in order to select multiple files.")
parser.add_argument("--use-ansi", action = "store_true", default = False, help = "Use ANSI escape sequences to print colored error messages if the output formatter supports it.")
parser.add_argument("--only-used", action = "store_true", help = "Lint only those bibliography entries that are referenced within the given TeX files.")
parser.add_argument("--update-readme", action = "store_true", help = "Updates the README.md file automatically with the data from the available check classes. Usually only needed for development of biblint.")
parser.add_argument("-v", "--verbose", action = "store_true", help = "Be more verbose when checking")
parser.add_argument("bibfiles", metavar = "bibfile", type = str, nargs = "+", help = "Bibliography files which should be checked")
args = parser.parse_args(sys.argv[1:])

if args.update_readme:
	db.update_markdown()
	sys.exit(0)

apply_checks = db.get_check_classes(oset.parse(args.check))

bibliography = Bibliography(args.bibfiles)
if args.verbose:
	print("Parsed %d bibliography entries." % (len(bibliography)))

citations = None
for texfile_glob in args.tex:
	citations = Citations()
	for filename in glob.glob(texfile_glob):
		citations.read_from_file(filename)
	if args.verbose:
		print("Parsed %d citations from TeX." % (len(citations)))

if args.output == "-":
	outfile = sys.stdout
else:
	outfile = open(args.output, "w")

with outfile:
	if args.action == "lint":
		complaints = [ ]
		for check_class in apply_checks:
			if args.verbose:
				print("Now checking %s" % (check_class.name))

			checker = check_class(args, bibliography, citations)
			if check_class.linttype == "per_entry":
				for entry in bibliography:
					if (not args.ignore_suppressions) and entry.suppressed(check_class.name):
						# Ignore this entry because of active suppresion
						continue
					if args.only_used and (not citations.citation_used(entry.name)):
						# Ignore this entry because it is never cited from TeX
						continue

					for complaint in checker.check_entry(entry):
						complaints.append(complaint)
			elif check_class.linttype == "once":
				for complaint in checker.check_all():
					complaints.append(complaint)
			else:
				raise Exception("Unknown linttype %s for checker %s" % (check_class.linttype, check_class.name))
		complaints.sort()

		if args.verbose:
			print("%d complaints found." % (len(complaints)))

		if args.format == "short":
			for complaint in complaints:
				complaint.short_dump(file = outfile)
		elif args.format == "long":
			for complaint in complaints:
				complaint.long_dump(file = outfile)
		elif args.format == "json":
			complaint_data = [ complaint.to_dict() for complaint in complaints ]
			print(json.dumps(complaint_data), file = outfile)
		elif args.format == "html":
			renderer = HTMLComplaintRenderer(complaints)
			print(renderer.render(), file = outfile)
		elif args.format == "quickfix":
			for complaint in complaints:
				complaint.print_vim_quickfix(outfile)
		else:
			raise Exception(NotImplemented)
	elif args.action == "authorscan":
		BibUtils(bibliography).author_scan(file = outfile)
	elif args.action == "prettyprint":
		bibliography.pretty_print(file = outfile)
	else:
		raise Exception(NotImplemented)

